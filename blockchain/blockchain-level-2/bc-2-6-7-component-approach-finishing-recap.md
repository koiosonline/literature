# BC-2.6.7 Component approach (finishing recap) 

So instead of just a random number hashed (public key Bitcoin), Ethereum adds (in addition!) also the possibility to hash written software code. 

However, the outcome of the hashed data is still the same. As shown in section 1: it doesn’t matter what data you hash. The length of the hash is still the same. This is because, where we read text, a computer still reads a number (so it still hashes a vast random number). 

So now we can add more data in a public key and program that data (= write code in it / create a digital decision tree). You must realize that you can’t alter the code later because the data changes, leading to a different hash / public key. So when you aim to automate the recording of transactions, you need to consider all the components in advance. The other variables and entities and the different scenarios / possible outcomes need to be accounted for. 


